---
title: "occ_mapping"
author: "Sophie"
date: "2023-12-27"
output: html_document
---



```{r}
library(sf)
library(here)
library(readxl)
library(dplyr)
library(ggplot2)
library(ggpubr)
```


```{r}

#read in census occupational data by district

census_occs <- read_excel(here::here("input_data",
                                    "occ_by_dist_perc.xls"))

census_occs <- census_occs %>%
  rename(ID_2 =district_n, "Industry workers" ="Indusrtry Workers")

census_occs_n <- read_excel(here::here("input_data",
                                    "occ_by_dist_n.xls"))

census_occs_n <- census_occs_n %>%
  rename(ID_2 =district_n, "Industry workers" ="Indusrtry Workers")


```


```{r}

# read in the district level shape file for zim EPSG:20936, ID2 is district
zim_60d <- st_read(here::here("input_data",
                          "60_districts", 
                          "ZWE_adm2.shp")) %>%
  st_transform(., 20936) 

plot(zim_60d["ID_2"])

```


```{r}
# join the occupational data with the shapefile based on the district number using merge function (because that's join by attributes)

merged_data <- merge(zim_60d, census_occs, by = "ID_2")
merged_data_n <- merge(zim_60d, census_occs_n, by="ID_2")
```

```{r}
 #now can plot the distribution of each of the occupations and see how they vary across the country 

plot(merged_data["Office workers"])

# Create a list of variables (for each occupation)
variables <- c("Current Students", "Service Workers", "Agriculture Workers", "Industry workers", "Not working, inactive, not in universe", "Homemakers/Housework")

# Create a list to store the ggplot objects
plots <- list()

# Create a quadrant of maps
for (i in seq_along(variables)) {
  # Create a ggplot for each variable
  plot <- ggplot() +
    geom_sf(data = merged_data, aes(fill = !!sym(variables[i]))) +
    scale_fill_viridis_c(option = "C", direction = -1)  +  # Choose a suitable color scale
    ggtitle(variables[i]) +
    labs(fill = "% of population") +  # Rename the legend
    theme_void() +
    theme(
      plot.title = element_text(margin = margin(b = 10)),  # Adjust title margin
      legend.position = "right"  # Move legend to the right
    )

  # Add the ggplot object to the list
  plots[[i]] <- plot
}

# Arrange the plots in a quadrant
final_plot <- ggarrange(plotlist = plots, ncol = 2, nrow = 3, common.legend=TRUE)+
  theme(plot.margin = margin(0.5, 0.5, 1, 0.5, "cm"))  # Adjust margin between rows

# Increase the size of individual plots
final_plot <- final_plot + theme(
  plot.margin = margin(0.5, 0.5, 1, 0.5, "cm"),  # Adjust overall plot margin
  plot.background = element_rect(fill = "white", color = NA),
  panel.background = element_rect(fill = "white", color = NA)
)

# Display the final plot
print(final_plot)

# Export the final plot as a PNG with DPI set to 300
ggsave("occupations_by_dist_perc.png", final_plot, dpi = 300, width = 10, height = 8)

```


```{r}
# Do the same but with the absolute number rather than percentage 
#now can plot the distribution of each of the occupations and see how they vary across the country 

# Create a list of variables (for each occupation)
variables <- c("Current Students", "Service Workers", "Agriculture Workers", "Industry workers", "Not working, inactive, not in universe", "Homemakers/Housework")

# Create a list to store the ggplot objects
plots <- list()

# Create a quadrant of maps
for (i in seq_along(variables)) {
  # Create a ggplot for each variable
  plot <- ggplot() +
    geom_sf(data = merged_data_n, aes(fill = !!sym(variables[i]))) +
    scale_fill_viridis_c(option = "C", direction = -1)  +  # Choose a suitable color scale
    ggtitle(variables[i]) +
    labs(fill = "n of population") +  # Rename the legend
    theme_void() +
    theme(
      plot.title = element_text(margin = margin(b = 10)),  # Adjust title margin
      legend.position = "right"  # Move legend to the right
    )

  # Add the ggplot object to the list
  plots[[i]] <- plot
}

# Arrange the plots in a quadrant
final_plot <- ggarrange(plotlist = plots, ncol = 2, nrow = 3, common.legend=TRUE)+
  theme(plot.margin = margin(0.5, 0.5, 1, 0.5, "cm"))  # Adjust margin between rows

# Increase the size of individual plots
final_plot <- final_plot + theme(
  plot.margin = margin(0.5, 0.5, 1, 0.5, "cm"),  # Adjust overall plot margin
  plot.background = element_rect(fill = "white", color = NA),
  panel.background = element_rect(fill = "white", color = NA)
)

# Display the final plot
print(final_plot)

# Export the final plot as a PNG with DPI set to 300
ggsave("occupations_by_dist_n.png", final_plot, dpi = 300, width = 10, height = 8)

```


```{r}

Joinfun <- function(data1, data2){

output<- data1%>%
  st_join(data2,.) %>%
  add_count(GSS_CODE, name="hotels_in_borough") 

  return(output)
}

# use the function for hotels
Hotels <- Joinfun(OSM, Londonborough)

# then for airbnb
Airbnb <- Joinfun(Airbnb, Londonborough)
 

```

```{r}
#getting to just use UK cities subset
Worldcities2 <- Worldcities %>%
  filter(CNTRY_NAME=='United Kingdom'&
           Worldcities$CITY_NAME=='Birmingham'|
           Worldcities$CITY_NAME=='London'|
           Worldcities$CITY_NAME=='Edinburgh')

newbb <- c(xmin=-296000, ymin=5408, xmax=655696, ymax=1000000)
  
UK_outlinecrop <- UK_outline$geometry %>%
  st_crop(., newbb)
```

```{r}
Hotels <- Hotels %>%
  #at the moment each hotel is a row for the borough
  #we just one one row that has number of airbnbs
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))

#making the same summary for airbnb
Airbnb <- Airbnb %>%
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = unique(hotels_in_borough))
```

```{r}
library(tmap)
tmap_mode("plot")

# set the breaks
# for our mapped data
breaks = c(0, 5, 12, 26, 57, 286) 

# plot each map
tm1 <- tm_shape(Hotels) + 
  tm_polygons("Accomodation count", 
              breaks=breaks,
              palette="PuBu")+
  tm_legend(show=FALSE)+
  tm_layout(frame=FALSE)+
  tm_credits("(a)", position=c(0,0.85), size=1.5)

tm2 <- tm_shape(Airbnb) + 
  tm_polygons("Accomodation count",
              breaks=breaks, 
              palette="PuBu") + 
  tm_legend(show=FALSE)+
  tm_layout(frame=FALSE)+
  tm_credits("(b)", position=c(0,0.85), size=1.5)

tm3 <- tm_shape(UK_outlinecrop)+ 
  tm_polygons(col="darkslategray1")+
  tm_layout(frame=FALSE)+
  tm_shape(Worldcities2) +
  tm_symbols(col = "red", scale = .5)+
  tm_text("CITY_NAME", xmod=-1, ymod=-0.5)

legend <- tm_shape(Hotels) +
    tm_polygons("Accomodation count",
                palette="PuBu") +
    tm_scale_bar(position=c(0.2,0.04), text.size=0.6)+
    tm_compass(north=0, position=c(0.65,0.6))+
    tm_layout(legend.only = TRUE, legend.position=c(0.2,0.25),asp=0.1)+
    tm_credits("(c) OpenStreetMap contrbutors and Air b n b", position=c(0.0,0.0))
  
t=tmap_arrange(tm1, tm2, tm3, legend, ncol=2)

t
```


```{r}
library(grid)
# erases the current device or moves to a new page 
# probably not needed but makes sure you are plotting on a new page.
grid.newpage()

pushViewport(viewport(layout=grid.layout(2,2)))
print(tm1, vp=viewport(layout.pos.col=1, layout.pos.row=1, height=5))
print(tm2, vp=viewport(layout.pos.col=2, layout.pos.row=1, height=5))
print(tm3, vp=viewport(layout.pos.col=1, layout.pos.row=2, height=5))
print(legend, vp=viewport(layout.pos.col=2, layout.pos.row=2, height=5))
```


```{r}
Londonbb <- st_bbox(Airbnb,
                    crs = st_crs(Airbnb))%>%
  #we need this to convert it into a class of sf
  # otherwise it our bb won't have a class it will just be x and y coordinates for the box
  # this makes it into a polygon
  st_as_sfc()

```

```{r}
main <- tm_shape(Airbnb, bbbox = Londonbb) + 
  tm_polygons("Accomodation count",
              breaks=breaks, 
              palette="PuBu")+
  tm_scale_bar(position = c("left", "bottom"), text.size = .75)+
  tm_layout(legend.position = c("right","top"), 
            legend.text.size=.75, 
            legend.title.size = 1.1,
            frame=FALSE)+
  tm_credits("(c) OpenStreetMap contrbutors and Air b n b", position=c(0.0,0.0))+
  #tm_text(text = "NAME", size = .5, along.lines =T, remove.overlap=T,  auto.placement=F)+
  tm_compass(type = "8star", position = c(0.06, 0.1)) +

  #bottom left top right
  tm_layout(inner.margin=c(0.02,0.02,0.02,0.2))

main
```

```{r}
library(leafpop)
inset = tm_shape(UK_outlinecrop) + tm_polygons() +
  tm_shape(Londonbb)+ 
  tm_borders(col = "grey40", lwd = 3)+
    tm_layout(frame=FALSE,
            bg.color = "transparent")+
  tm_shape(Worldcities2) +
  tm_symbols(col = "red", scale = .5)+
  tm_text("CITY_NAME", xmod=-1.5, ymod=-0.5)

inset
```

```{r}
library(grid)

main
print(inset, vp = viewport(0.86, 0.29, width = 0.5, height = 0.55))
```

```{r}
#output the
tmap_save(t, 'hotelsandairbnbR.png')

library(grid)
tmap_save(main,insets_tm = inset,insets_vp=viewport(x=0.86, y=0.29, width=.5, height=.55), filename="output_data/test.pdf", dpi=600)
```

```{r}
#make interactive map 
tmap_mode("view")

tm_shape(Airbnb) + 
  tm_polygons("Accomodation count", breaks=breaks) 

```

```{r}
#interactive map where I can select individual components
# library for pop up boxes
library(leafpop)
library(leaflet)

#join data
Joined <- Airbnb%>%
  st_join(., Hotels, join = st_equals)%>%
  dplyr::select(GSS_CODE.x, NAME.x, `Accomodation count.x`, `Accomodation count.y`)%>%
  dplyr::rename(`GSS code` =`GSS_CODE.x`,
                `Borough` = `NAME.x`,
                `Airbnb count` = `Accomodation count.x`,
                `Hotel count`= `Accomodation count.y`)%>%
  st_transform(., 4326)
  
  
#remove the geometry for our pop up boxes to avoid
popupairbnb <-Joined %>%
  st_drop_geometry()%>%
  dplyr::select(`Airbnb count`, Borough)%>%
  popupTable()

popuphotel <-Joined %>%
  st_drop_geometry()%>%
  dplyr::select(`Hotel count`, Borough)%>%
  popupTable()

tmap_mode("view")

# set the colour palettes using our previously defined breaks


pal1 <- Joined %>%
  colorBin(palette = "YlOrRd", domain=.$`Airbnb count`, bins=breaks)

pal1 <-colorBin(palette = "YlOrRd", domain=Joined$`Airbnb count`, bins=breaks)

pal2 <- Joined %>%
  colorBin(palette = "YlOrRd", domain=.$`Hotel count`, bins=breaks)


map<- leaflet(Joined) %>%
  # add basemap options
  addTiles(group = "OSM (default)") %>%
  addProviderTiles(providers$Stamen.Toner, group = "Toner") %>%
  addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "CartoDB")%>%
  
  #add our polygons, linking to the tables we just made
  addPolygons(color="white", 
              weight = 2,
              opacity = 1,
              dashArray = "3",
              popup = popupairbnb,
              fillOpacity = 0.7,
              fillColor = ~pal2(`Airbnb count`),
              group = "Airbnb")%>%
  
  addPolygons(fillColor = ~pal2(`Hotel count`), 
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              popup = popupairbnb,
              fillOpacity = 0.7,group = "Hotels")%>%
  # add a legend
  addLegend(pal = pal2, values = ~`Hotel count`, group = c("Airbnb","Hotel"), 
            position ="bottomleft", title = "Accomodation count") %>%
  # specify layers control
  addLayersControl(
    baseGroups = c("OSM (default)", "Toner", "Toner Lite", "CartoDB"),
    overlayGroups = c("Airbnb", "Hotels"),
    options = layersControlOptions(collapsed = FALSE)
  )

# plot the map
map
```


